---
layout: single
title: Vulnserver Exploiting GMON with SEH Overwrite
date: 2019-7-6
classes: wide
tags:
    - buffer overflow
    - Windows
    - SEH
    - OSCE
    - CTP
    - Python
    - Exploit Development
---

UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT



And I'm back with another write up tracking my progress figuring out all the ways to break vulnserver! This time we will fuzz and break the `GMON` command. This time we will see that it's not a classic buffer overflow, but rather a very specific overflow that requires a bit more work to make it work for us. Without going into more detail too early, let's start fuzzing the application!


Fuzzing GMON Command
---------------------

Just like the [previous](https://anubissec.github.io/Vulnserver-Exploiting-TRUN-Vanilla-EIP-Overwrite/) blog post, we will be using `boofuzz` to fuzz the application and figure out the beginning steps of breaking this command.

Since I went through it in depth last time, I will just post the full fuzzing code instead of going block by block. It's essentialls the same as the last setup, but we change the command from `TRUN` to `GMON`. Here is the code:


```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.17.129'
port = 9999

def main():

        session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')), sleep_time = 3)

        s_initialize("VULN")

        s_string("GMON", fuzzable=False)
        s_delim(" ", fuzzable=False)
        s_string("BLAH")

        session.connect(s_get("VULN"))
        session.fuzz()

if __name__ == "__main__":
    main()
```

As mentioned above, this is all the same, except for the first `s_string` variable is different. So with this variable changed to test out, let's run this and see what happens!

< IMMUNITY OUTPUT 1 >


< IMMUNITY OUTPUT 2 >


This looks a bit off from what was seen in the last blog. We definitely crashed the app, but EIP was not overwritten. That's no good. Let's take a look at the SEH windows within Immunity and see what it says.


< Immunity SEH windows >


Well this is a bit more interesting. It looks like we have overwritten the SEH value and the pointer to the next SEH value with "A"s! Before we move on to the developement part of this, let's take a beat and talk about what SEH actually is!




Structured Exception Handler (SEH) Explanation
-----------------------------------------------

The best place to learn about what SEH is and how it works (and how to break it), the [Corelan](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/) team has an amazing resource in which this paragraph is found:

*"Windows has a default SEH (Structured Exception Handler) which will catch exceptions. If Windows catches an exception, you’ll see a “xxx has encountered a problem and needs to close” popup. This is often the result of the default handler kicking in.  It is obvious that, in order to write stable software, one should try to use development language specific exception handlers, and only rely on the windows default SEH as a last resort.   When using language EH’s, the necessary links and calls to the exception handling code are generate in accordance with the underlying OS.  (and when no exception handlers are used, or when the available exception handlers cannot process the exception, the Windows SEH will be used. (UnhandledExceptionFilter)).  So in the event an error or illegal instruction occurs, the application will get a chance to catch the exception and do something with it. If no exception handler is defined in the application, the OS takes over, catches the exception, shows the popup (asking you to Send Error Report to MS)."*

TL;DR, SEH is error handling that happens when things go bad on an application. Windows generally tells you when an application is having a hard time, and exploiting this catching mechanism can yield some pretty juicy results.

Now that we have a little history, and you have a resource available if you'd like to learn more, let's jump into developing our custom exploit script, and hopefully it will help solidify this infomration!


Cooking up some Exploit Code
-----------------------------

So the beginning steps of every exploit script will generally be the same, set up the connection and customize payload to match the crash found with `boofuzz`. If we look back at the Immunity output above, we see the ASCII string "GMON /.:/AAAA....". Let's look back in our terminal where we ran boofuzz and see how many bytes it sent with that payload.

< Boofuzz crash output >


If you take a close look, you see that `boofuzz` told us that it sent 5011 bytes when the crash occurred, and pay special attention to the highlighted text as well. This is hex value, and a quick conversion shows us some familiar ASCII:


<script id="asciicast-256073" src="https://asciinema.org/a/256073.js" async></script>


Look at that! It decodes to "GMON /.:/". Awesome, that's a bit easier than setting up the database and looking for the entries like last time (since this was the first output when running `boofuzz`, it was easier, but if there is a lot of output then it's probably best to go to the database).

So now that we have the amount of bytes and the string to send the server, lets start writing our exploit code. Again, it will be more or less the same as last time, just with some minor tweaks to acommodate our new command and string. One other thing that I'm going to switch up is, instead of using the `socket` library for Python, I'm going to try out the [pwntools](http://docs.pwntools.com/en/stable/) library. This library is specifically created for exploit development, and I've used it for different CTF challenges, so I thought I would give it a shot here.

I'm not going to spell out what each line does, but I provided comments on each line in the script that hopefully describes what's going on.


```python
#!/usr/bin/python
from pwn import *


host = "192.168.17.129"     # Windows VM
port = 9999                 # Vulnserver port


buffer = "A" * 5011         # Buffer to crash vulnserver

conn = remote(host, port)   # pwntools way to connect to host
conn.recvline()             # receive connection to host

conn.send("GMON /.:/" + buffer)     # send evil buffer

conn.close()                        # Close connection if not hung
```

So it's pretty self-explanatory and similar to the last blog. So let's go ahead and run this and see what happens.

<script id="asciicast-256075" src="https://asciinema.org/a/256075.js" async></script>


< SEHOverflowExploitA >


And we are good to good. So now we will go through the same steps of finding out the exact number of bytes that causes our overwrite[s]. This is going to be a tad different for that, since we are now trying to control the SEH address and the next SEH address. So what we will do first is create a unique 5011 byte string to send to the target. I will be doing this in a different fashion as before, but with the same basic concept in mind. `pwntools` comes with a function called `cyclic(int)` which creates a unique string of however many characters you need. No more copying and pasting! This is how I will update the script:

```python
buffer = cyclic(5011)
```

And that's it! Easy enough. Let's check out the SEH values!

< cyclicSEHCrash output >


So for the first line, we will copy the value that's under the "SE Handler" column, since that is our actual SEH value, and we will also copy the value on the next line down, but copy the actual address value (obviously not the corrupt part) sinct that's pointing to the next SEH. We will now use `pwntools` to find our offset. It's not as easy with pwntools to do this as it is with `pattern_offset.rb`, but I wrote a VERY basic [script](https://github.com/AnubisSec/FindPwn) that will take your input from Immunity and find the offset for it using `pwntools`. Here is an example of me running within the Python console and then me running it with my script.


<script id="asciicast-256086" src="https://asciinema.org/a/256086.js" async></script>



