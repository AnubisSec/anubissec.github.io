---
layout: single
title: Vulnserver Exploiting GMON with SEH Overwrite
date: 2019-7-6
classes: wide
tags:
    - buffer overflow
    - Windows
    - SEH
    - OSCE
    - CTP
    - Python
    - Exploit Development
---

UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT   UNDER DEVELOPMENT



And I'm back with another write up tracking my progress figuring out all the ways to break vulnserver! This time we will fuzz and break the `GMON` command. This time we will see that it's not a classic buffer overflow, but rather a very specific overflow that requires a bit more work to make it work for us. Without going into more detail too early, let's start fuzzing the application!


Fuzzing GMON Command
---------------------

Just like the [previous](https://anubissec.github.io/Vulnserver-Exploiting-TRUN-Vanilla-EIP-Overwrite/) blog post, we will be using `boofuzz` to fuzz the application and figure out the beginning steps of breaking this command.

Since I went through it in depth last time, I will just post the full fuzzing code instead of going block by block. It's essentialls the same as the last setup, but we change the command from `TRUN` to `GMON`. Here is the code:


```python
#!/usr/bin/python

from boofuzz import *

host = '192.168.17.129'
port = 9999

def main():

        session = Session(target = Target(connection = SocketConnection(host, port, proto='tcp')), sleep_time = 3)

        s_initialize("VULN")

        s_string("GMON", fuzzable=False)
        s_delim(" ", fuzzable=False)
        s_string("BLAH")

        session.connect(s_get("VULN"))
        session.fuzz()

if __name__ == "__main__":
    main()
```

As mentioned above, this is all the same, except for the first `s_string` variable is different. So with this variable changed to test out, let's run this and see what happens!

< IMMUNITY OUTPUT 1 >


< IMMUNITY OUTPUT 2 >


This looks a bit off from what was seen in the last blog. We definitely crashed the app, but EIP was not overwritten. That's no good. Let's take a look at the SEH windows within Immunity and see what it says.


< Immunity SEH windows >


Well this is a bit more interesting. It looks like we have overwritten the SEH value and the pointer to the next SEH value with "A"s! Before we move on to the developement part of this, let's take a beat and talk about what SEH actually is!




Structured Exception Handler (SEH) Explanation
-----------------------------------------------

The best place to learn about what SEH is and how it works (and how to break it), the [Corelan](https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/) team has an amazing resource in which this paragraph is found:

*"Windows has a default SEH (Structured Exception Handler) which will catch exceptions. If Windows catches an exception, you’ll see a “xxx has encountered a problem and needs to close” popup. This is often the result of the default handler kicking in.  It is obvious that, in order to write stable software, one should try to use development language specific exception handlers, and only rely on the windows default SEH as a last resort.   When using language EH’s, the necessary links and calls to the exception handling code are generate in accordance with the underlying OS.  (and when no exception handlers are used, or when the available exception handlers cannot process the exception, the Windows SEH will be used. (UnhandledExceptionFilter)).  So in the event an error or illegal instruction occurs, the application will get a chance to catch the exception and do something with it. If no exception handler is defined in the application, the OS takes over, catches the exception, shows the popup (asking you to Send Error Report to MS)."*

TL;DR, SEH is error handling that happens when things go bad on an application. Windows generally tells you when an application is having a hard time, and exploiting this catching mechanism can yield some pretty juicy results.

Now that we have a little history, and you have a resource available if you'd like to learn more, let's jump into developing our custom exploit script, and hopefully it will help solidify this infomration!


Cooking up some Exploit Code
-----------------------------

So the beginning steps of every exploit script will generally be the same, set up the connection and customize payload to match the crash found with `boofuzz`. If we look back at the Immunity output above, we see the ASCII string "GMON /.:/AAAA....". Let's look back in our terminal where we ran boofuzz and see how many bytes it sent with that payload.

< Boofuzz crash output >


If you take a close look, you see that `boofuzz` told us that it sent 5011 bytes when the crash occurred, and pay special attention to the highlighted text as well. This is hex value, and a quick conversion shows us some familiar ASCII:

{% asciicast 256070 %}


